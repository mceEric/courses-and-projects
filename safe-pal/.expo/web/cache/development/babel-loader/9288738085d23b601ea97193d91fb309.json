{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"style\", \"children\"],\n    _excluded2 = [\"component\"];\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport * as React from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport SafeAreaView from \"react-native-web/dist/exports/SafeAreaView\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { polyfill } from 'react-lifecycles-compat';\nimport color from 'color';\nimport Icon from \"./Icon\";\nimport Surface from \"./Surface\";\nimport TouchableRipple from \"./TouchableRipple\";\nimport Text from \"./Typography/Text\";\nimport { black, white } from \"../styles/colors\";\nimport { withTheme } from \"../core/theming\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nvar AnimatedText = Animated.createAnimatedComponent(Text);\nvar MIN_RIPPLE_SCALE = 0.001;\nvar MIN_TAB_WIDTH = 96;\nvar MAX_TAB_WIDTH = 168;\nvar BAR_HEIGHT = 56;\nvar FAR_FAR_AWAY = 9999;\nvar Touchable = Platform.OS === 'android' ? TouchableRipple : function (_ref) {\n  var style = _ref.style,\n      children = _ref.children,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return _jsx(TouchableWithoutFeedback, _objectSpread(_objectSpread({}, rest), {}, {\n    children: _jsx(View, {\n      style: style,\n      children: children\n    })\n  }));\n};\n\nvar SceneComponent = function (_React$PureComponent) {\n  _inherits(SceneComponent, _React$PureComponent);\n\n  var _super = _createSuper(SceneComponent);\n\n  function SceneComponent() {\n    _classCallCheck(this, SceneComponent);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SceneComponent, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          component = _this$props.component,\n          rest = _objectWithoutProperties(_this$props, _excluded2);\n\n      return React.createElement(component, rest);\n    }\n  }]);\n\n  return SceneComponent;\n}(React.PureComponent);\n\nvar BottomNavigation = function (_React$Component) {\n  _inherits(BottomNavigation, _React$Component);\n\n  var _super2 = _createSuper(BottomNavigation);\n\n  function BottomNavigation(props) {\n    var _this;\n\n    _classCallCheck(this, BottomNavigation);\n\n    _this = _super2.call(this, props);\n\n    _this._handleLayout = function (e) {\n      return _this.setState({\n        layout: {\n          height: e.nativeEvent.layout.height,\n          width: e.nativeEvent.layout.width,\n          measured: true\n        }\n      });\n    };\n\n    _this._handleTabPress = function (index) {\n      var _this$props2 = _this.props,\n          navigationState = _this$props2.navigationState,\n          onTabPress = _this$props2.onTabPress,\n          onIndexChange = _this$props2.onIndexChange;\n\n      if (onTabPress) {\n        onTabPress({\n          route: navigationState.routes[index]\n        });\n      }\n\n      if (index !== navigationState.index) {\n        onIndexChange(index);\n      }\n    };\n\n    _this._jumpTo = function (key) {\n      var index = _this.props.navigationState.routes.findIndex(function (route) {\n        return route.key === key;\n      });\n\n      _this.props.onIndexChange(index);\n    };\n\n    _this._isShifting = function () {\n      return typeof _this.props.shifting === 'boolean' ? _this.props.shifting : _this.props.navigationState.routes.length > 3;\n    };\n\n    var _index = _this.props.navigationState.index;\n    _this.state = {\n      tabs: [],\n      offsets: [],\n      index: new Animated.Value(_index),\n      ripple: new Animated.Value(MIN_RIPPLE_SCALE),\n      touch: new Animated.Value(MIN_RIPPLE_SCALE),\n      layout: {\n        height: 0,\n        width: 0,\n        measured: false\n      },\n      current: _index,\n      previous: 0,\n      loaded: [_index]\n    };\n    return _this;\n  }\n\n  _createClass(BottomNavigation, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this2 = this;\n\n      if (prevProps.navigationState.index === this.props.navigationState.index) {\n        return;\n      }\n\n      var shifting = this._isShifting();\n\n      var _this$props$navigatio = this.props.navigationState,\n          routes = _this$props$navigatio.routes,\n          index = _this$props$navigatio.index;\n      this.state.offsets.forEach(function (offset, i) {\n        if (i === index || i === prevProps.navigationState.index) {\n          offset.setValue(0);\n        }\n      });\n      this.state.ripple.setValue(MIN_RIPPLE_SCALE);\n      Animated.parallel([Animated.timing(this.state.ripple, {\n        toValue: 1,\n        duration: shifting ? 400 : 0,\n        useNativeDriver: true\n      })].concat(_toConsumableArray(routes.map(function (_, i) {\n        return Animated.timing(_this2.state.tabs[i], {\n          toValue: i === index ? 1 : 0,\n          duration: shifting ? 150 : 75,\n          useNativeDriver: true\n        });\n      })))).start(function (_ref2) {\n        var finished = _ref2.finished;\n\n        _this2.state.tabs.map(function (tab, i) {\n          return tab.setValue(i === index ? 1 : 0);\n        });\n\n        _this2.state.index.setValue(index);\n\n        _this2.state.ripple.setValue(MIN_RIPPLE_SCALE);\n\n        if (finished) {\n          _this2.state.offsets.forEach(function (offset, i) {\n            if (i === index) {\n              offset.setValue(0);\n            } else {\n              offset.setValue(1);\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props3 = this.props,\n          navigationState = _this$props3.navigationState,\n          renderScene = _this$props3.renderScene,\n          renderIcon = _this$props3.renderIcon,\n          renderLabel = _this$props3.renderLabel,\n          _this$props3$getLabel = _this$props3.getLabelText,\n          getLabelText = _this$props3$getLabel === void 0 ? function (_ref3) {\n        var route = _ref3.route;\n        return route.title;\n      } : _this$props3$getLabel,\n          _this$props3$getColor = _this$props3.getColor,\n          getColor = _this$props3$getColor === void 0 ? function (_ref4) {\n        var route = _ref4.route;\n        return route.color;\n      } : _this$props3$getColor,\n          _this$props3$getAcces = _this$props3.getAccessibilityLabel,\n          getAccessibilityLabel = _this$props3$getAcces === void 0 ? function (_ref5) {\n        var route = _ref5.route;\n        return route.accessibilityLabel;\n      } : _this$props3$getAcces,\n          _this$props3$getTestI = _this$props3.getTestID,\n          getTestID = _this$props3$getTestI === void 0 ? function (_ref6) {\n        var route = _ref6.route;\n        return route.testID;\n      } : _this$props3$getTestI,\n          activeColor = _this$props3.activeColor,\n          inactiveColor = _this$props3.inactiveColor,\n          barStyle = _this$props3.barStyle,\n          labeled = _this$props3.labeled,\n          style = _this$props3.style,\n          theme = _this$props3.theme;\n      var _this$state = this.state,\n          layout = _this$state.layout,\n          loaded = _this$state.loaded;\n      var routes = navigationState.routes;\n      var colors = theme.colors;\n\n      var shifting = this._isShifting();\n\n      var _ref7 = StyleSheet.flatten(barStyle) || {},\n          _ref7$backgroundColor = _ref7.backgroundColor,\n          approxBackgroundColor = _ref7$backgroundColor === void 0 ? colors.primary : _ref7$backgroundColor;\n\n      var backgroundColor = shifting ? this.state.index.interpolate({\n        inputRange: routes.map(function (_, i) {\n          return i;\n        }),\n        outputRange: routes.map(function (route) {\n          return getColor({\n            route: route\n          }) || approxBackgroundColor;\n        })\n      }) : approxBackgroundColor;\n      var isDark = !color(approxBackgroundColor).light();\n      var textColor = isDark ? white : black;\n      var activeTintColor = typeof activeColor !== 'undefined' ? activeColor : textColor;\n      var inactiveTintColor = typeof inactiveColor !== 'undefined' ? inactiveColor : color(textColor).alpha(0.5).rgb().string();\n      var touchColor = color(textColor).alpha(0.12).rgb().string();\n      var maxTabWidth = routes.length > 3 ? MIN_TAB_WIDTH : MAX_TAB_WIDTH;\n      var tabWidth = Math.min(layout.width * 4 / routes.length, maxTabWidth);\n      return _jsxs(View, {\n        style: [styles.container, style],\n        onLayout: this._handleLayout,\n        pointerEvents: layout.measured ? 'auto' : 'none',\n        children: [_jsx(View, {\n          style: [styles.content, {\n            backgroundColor: colors.background\n          }],\n          children: routes.map(function (route, index) {\n            if (!loaded.includes(index)) {\n              return null;\n            }\n\n            var opacity = _this3.state.tabs[index];\n\n            var top = _this3.state.offsets[index].interpolate({\n              inputRange: [0, 1],\n              outputRange: [0, FAR_FAR_AWAY]\n            });\n\n            var focused = navigationState.index === index;\n            return _jsx(Animated.View, {\n              pointerEvents: focused ? 'auto' : 'none',\n              accessibilityElementsHidden: !focused,\n              importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',\n              style: [StyleSheet.absoluteFill, {\n                opacity: opacity\n              }],\n              collapsable: false,\n              removeClippedSubviews: Platform.OS === 'ios' ? navigationState.index !== index : true,\n              children: _jsx(Animated.View, {\n                style: [styles.content, {\n                  top: top\n                }],\n                children: renderScene({\n                  route: route,\n                  jumpTo: _this3._jumpTo\n                })\n              })\n            }, route.key);\n          })\n        }), _jsx(Surface, {\n          style: [styles.bar, barStyle, {\n            backgroundColor: backgroundColor\n          }],\n          children: _jsxs(SafeAreaView, {\n            style: [styles.items, {\n              maxWidth: maxTabWidth * routes.length\n            }],\n            children: [shifting ? _jsx(Animated.View, {\n              pointerEvents: \"none\",\n              style: [styles.ripple, {\n                top: BAR_HEIGHT / 2 - layout.width / 8,\n                left: navigationState.index * tabWidth + tabWidth / 2 - layout.width / 8,\n                height: layout.width / 4,\n                width: layout.width / 4,\n                borderRadius: layout.width / 2,\n                backgroundColor: getColor({\n                  route: routes[navigationState.index]\n                }),\n                transform: [{\n                  scale: this.state.ripple.interpolate({\n                    inputRange: [0, 1],\n                    outputRange: [0, 8]\n                  })\n                }],\n                opacity: this.state.ripple.interpolate({\n                  inputRange: [0, MIN_RIPPLE_SCALE, 0.3, 1],\n                  outputRange: [0, 0, 1, 1]\n                })\n              }]\n            }) : null, routes.map(function (route, index) {\n              var focused = navigationState.index === index;\n              var active = _this3.state.tabs[index];\n              var scale = labeled && shifting ? active.interpolate({\n                inputRange: [0, 1],\n                outputRange: [0.5, 1]\n              }) : 1;\n              var translateY = labeled ? shifting ? active.interpolate({\n                inputRange: [0, 1],\n                outputRange: [7, 0]\n              }) : 0 : 7;\n              var activeOpacity = active;\n              var inactiveOpacity = active.interpolate({\n                inputRange: [0, 1],\n                outputRange: [1, 0]\n              });\n              return _jsx(Touchable, {\n                borderless: true,\n                rippleColor: touchColor,\n                onPress: function onPress() {\n                  return _this3._handleTabPress(index);\n                },\n                testID: getTestID({\n                  route: route\n                }),\n                accessibilityLabel: getAccessibilityLabel({\n                  route: route\n                }),\n                accessibilityTraits: focused ? ['button', 'selected'] : 'button',\n                accessibilityComponentType: \"button\",\n                accessibilityRole: \"button\",\n                accessibilityStates: ['selected'],\n                style: styles.item,\n                children: _jsxs(View, {\n                  pointerEvents: \"none\",\n                  children: [_jsxs(Animated.View, {\n                    style: [styles.iconContainer, {\n                      transform: [{\n                        translateY: translateY\n                      }]\n                    }],\n                    children: [_jsx(Animated.View, {\n                      style: [styles.iconWrapper, {\n                        opacity: activeOpacity\n                      }],\n                      children: renderIcon ? renderIcon({\n                        route: route,\n                        focused: true,\n                        color: activeTintColor\n                      }) : _jsx(Icon, {\n                        source: route.icon,\n                        color: activeTintColor,\n                        size: 24\n                      })\n                    }), _jsx(Animated.View, {\n                      style: [styles.iconWrapper, {\n                        opacity: inactiveOpacity\n                      }],\n                      children: renderIcon ? renderIcon({\n                        route: route,\n                        focused: false,\n                        color: inactiveTintColor\n                      }) : _jsx(Icon, {\n                        source: route.icon,\n                        color: inactiveTintColor,\n                        size: 24\n                      })\n                    })]\n                  }), labeled ? _jsxs(Animated.View, {\n                    style: [styles.labelContainer, {\n                      transform: [{\n                        scale: scale\n                      }]\n                    }],\n                    children: [_jsx(Animated.View, {\n                      style: [styles.labelWrapper, {\n                        opacity: activeOpacity\n                      }],\n                      children: renderLabel ? renderLabel({\n                        route: route,\n                        focused: true,\n                        color: activeTintColor\n                      }) : _jsx(AnimatedText, {\n                        style: [styles.label, {\n                          color: activeTintColor\n                        }],\n                        children: getLabelText({\n                          route: route\n                        })\n                      })\n                    }), shifting ? null : _jsx(Animated.View, {\n                      style: [styles.labelWrapper, {\n                        opacity: inactiveOpacity\n                      }],\n                      children: renderLabel ? renderLabel({\n                        route: route,\n                        focused: false,\n                        color: inactiveTintColor\n                      }) : _jsx(AnimatedText, {\n                        style: [styles.label, {\n                          color: inactiveTintColor\n                        }],\n                        children: getLabelText({\n                          route: route\n                        })\n                      })\n                    })]\n                  }) : _jsx(View, {\n                    style: styles.labelContainer\n                  })]\n                })\n              }, route.key);\n            })]\n          })\n        })]\n      });\n    }\n  }], [{\n    key: \"SceneMap\",\n    value: function SceneMap(scenes) {\n      return function (_ref8) {\n        var route = _ref8.route,\n            jumpTo = _ref8.jumpTo;\n        return _jsx(SceneComponent, {\n          component: scenes[route.key],\n          route: route,\n          jumpTo: jumpTo\n        }, route.key);\n      };\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var _nextProps$navigation = nextProps.navigationState,\n          index = _nextProps$navigation.index,\n          routes = _nextProps$navigation.routes;\n      var tabs = routes.map(function (_, i) {\n        return prevState.tabs[i] || new Animated.Value(i === index ? 1 : 0);\n      });\n      var offsets = routes.map(function (_, i) {\n        return prevState.offsets[i] || new Animated.Value(i === index ? 0 : 1);\n      });\n      var nextState = {\n        tabs: tabs,\n        offsets: offsets\n      };\n\n      if (index !== prevState.current) {\n        _extends(nextState, {\n          current: index,\n          previous: prevState.current,\n          loaded: prevState.loaded.includes(index) ? prevState.loaded : [].concat(_toConsumableArray(prevState.loaded), [index])\n        });\n      }\n\n      return nextState;\n    }\n  }]);\n\n  return BottomNavigation;\n}(React.Component);\n\nBottomNavigation.defaultProps = {\n  labeled: true\n};\npolyfill(BottomNavigation);\nexport default withTheme(BottomNavigation);\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  content: {\n    flex: 1\n  },\n  bar: {\n    elevation: 8,\n    overflow: 'hidden',\n    alignItems: 'center'\n  },\n  items: {\n    flexDirection: 'row'\n  },\n  item: {\n    flex: 1,\n    paddingVertical: 6\n  },\n  ripple: {\n    position: 'absolute'\n  },\n  iconContainer: {\n    height: 24,\n    width: 24,\n    marginTop: 2,\n    marginHorizontal: 12,\n    alignSelf: 'center'\n  },\n  iconWrapper: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n    alignItems: 'center'\n  }),\n  labelContainer: {\n    height: 16,\n    paddingBottom: 2\n  },\n  labelWrapper: _objectSpread({}, StyleSheet.absoluteFillObject),\n  label: {\n    fontSize: 12,\n    textAlign: 'center',\n    backgroundColor: 'transparent'\n  }\n});","map":{"version":3,"sources":["C:/projectpog/2022-ca326-travel-guide/MapDisplay/node_modules/react-native-paper/src/components/BottomNavigation.js"],"names":["React","polyfill","color","Icon","Surface","TouchableRipple","Text","black","white","withTheme","AnimatedText","Animated","createAnimatedComponent","MIN_RIPPLE_SCALE","MIN_TAB_WIDTH","MAX_TAB_WIDTH","BAR_HEIGHT","FAR_FAR_AWAY","Touchable","Platform","OS","style","children","rest","SceneComponent","props","component","createElement","PureComponent","BottomNavigation","_handleLayout","e","setState","layout","height","nativeEvent","width","measured","_handleTabPress","index","navigationState","onTabPress","onIndexChange","route","routes","_jumpTo","key","findIndex","_isShifting","shifting","length","state","tabs","offsets","Value","ripple","touch","current","previous","loaded","prevProps","forEach","offset","i","setValue","parallel","timing","toValue","duration","useNativeDriver","map","_","start","finished","tab","renderScene","renderIcon","renderLabel","getLabelText","title","getColor","getAccessibilityLabel","accessibilityLabel","getTestID","testID","activeColor","inactiveColor","barStyle","labeled","theme","colors","StyleSheet","flatten","backgroundColor","approxBackgroundColor","primary","interpolate","inputRange","outputRange","isDark","light","textColor","activeTintColor","inactiveTintColor","alpha","rgb","string","touchColor","maxTabWidth","tabWidth","Math","min","styles","container","content","background","includes","opacity","top","focused","absoluteFill","jumpTo","bar","items","maxWidth","left","borderRadius","transform","scale","active","translateY","activeOpacity","inactiveOpacity","item","iconContainer","iconWrapper","icon","labelContainer","labelWrapper","label","scenes","nextProps","prevState","nextState","Component","defaultProps","create","flex","elevation","overflow","alignItems","flexDirection","paddingVertical","position","marginTop","marginHorizontal","alignSelf","absoluteFillObject","paddingBottom","fontSize","textAlign"],"mappings":"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","sourcesContent":["/* @flow */\r\n/* eslint-disable react/no-multi-comp */\r\n\r\nimport * as React from 'react';\r\nimport {\r\n  View,\r\n  Animated,\r\n  TouchableWithoutFeedback,\r\n  SafeAreaView,\r\n  StyleSheet,\r\n  Platform,\r\n} from 'react-native';\r\nimport { polyfill } from 'react-lifecycles-compat';\r\nimport color from 'color';\r\nimport Icon from './Icon';\r\nimport Surface from './Surface';\r\nimport TouchableRipple from './TouchableRipple';\r\nimport Text from './Typography/Text';\r\nimport { black, white } from '../styles/colors';\r\nimport { withTheme } from '../core/theming';\r\nimport type { Theme } from '../types';\r\nimport type { IconSource } from './Icon';\r\n\r\nconst AnimatedText = Animated.createAnimatedComponent(Text);\r\n\r\ntype Route = $Shape<{\r\n  key: string,\r\n  title: string,\r\n  icon: IconSource,\r\n  color: string,\r\n  accessibilityLabel: string,\r\n  testID: string,\r\n}>;\r\n\r\ntype NavigationState<T: Route> = {\r\n  index: number,\r\n  routes: Array<T>,\r\n};\r\n\r\ntype Props<T> = {\r\n  /**\r\n   * Whether the shifting style is used, the active tab appears wider and the inactive tabs won't have a label.\r\n   * By default, this is `true` when you have more than 3 tabs.\r\n   */\r\n  shifting?: boolean,\r\n  /**\r\n   * Whether to show labels in tabs. When `false`, only icons will be displayed.\r\n   */\r\n  labeled?: boolean,\r\n  /**\r\n   * State for the bottom navigation. The state should contain the following properties:\r\n   *\r\n   * - `index`: a number reprsenting the index of the active route in the `routes` array\r\n   * - `routes`: an array containing a list of route objects used for rendering the tabs\r\n   *\r\n   * Each route object should contain the following properties:\r\n   *\r\n   * - `key`: a unique key to identify the route (required)\r\n   * - `title`: title of the route to use as the tab label\r\n   * - `icon`: icon to use as the tab icon, can be a string, an image source or a react component\r\n   * - `color`: color to use as background color for shifting bottom navigation\r\n   * - `accessibilityLabel`: accessibility label for the tab button\r\n   * - `testID`: test id for the tab button\r\n   *\r\n   * Example:\r\n   *\r\n   * ```js\r\n   * {\r\n   *   index: 1,\r\n   *   routes: [\r\n   *     { key: 'music', title: 'Music', icon: 'queue-music', color: '#3F51B5' },\r\n   *     { key: 'albums', title: 'Albums', icon: 'album', color: '#009688' },\r\n   *     { key: 'recents', title: 'Recents', icon: 'history', color: '#795548' },\r\n   *     { key: 'purchased', title: 'Purchased', icon: 'shopping-cart', color: '#607D8B' },\r\n   *   ]\r\n   * }\r\n   * ```\r\n   *\r\n   * `BottomNavigation` is a controlled component, which means the `index` needs to be updated via the `onIndexChange` callback.\r\n   */\r\n  navigationState: NavigationState<T>,\r\n  /**\r\n   * Callback which is called on tab change, receives the index of the new tab as argument.\r\n   * The navigation state needs to be updated when it's called, otherwise the change is dropped.\r\n   */\r\n  onIndexChange: (index: number) => mixed,\r\n  /**\r\n   * Callback which returns a react element to render as the page for the tab. Receives an object containing the route as the argument:\r\n   *\r\n   * ```js\r\n   * renderScene = ({ route, jumpTo }) => {\r\n   *   switch (route.key) {\r\n   *     case 'music':\r\n   *       return <MusicRoute jumpTo={jumpTo} />;\r\n   *     case 'albums':\r\n   *       return <AlbumsRoute jumpTo={jumpTo} />;\r\n   *   }\r\n   * }\r\n   * ```\r\n   *\r\n   * Pages are lazily rendered, which means that a page will be rendered the first time you navigate to it.\r\n   * After initial render, all the pages stay rendered to preserve their state.\r\n   *\r\n   * You need to make sure that your individual routes implement a `shouldComponentUpdate` to improve the performance.\r\n   * To make it easier to specify the components, you can use the `SceneMap` helper:\r\n   *\r\n   * ```js\r\n   * renderScene = BottomNavigation.SceneMap({\r\n   *   music: MusicRoute,\r\n   *   albums: AlbumsRoute,\r\n   * });\r\n   * ```\r\n   *\r\n   * Specifying the components this way is easier and takes care of implementing a `shouldComponentUpdate` method.\r\n   * Each component will receive the current route and a `jumpTo` method as it's props.\r\n   * The `jumpTo` method can be used to navigate to other tabs programmatically:\r\n   *\r\n   * ```js\r\n   * this.props.jumpTo('albums')\r\n   * ```\r\n   */\r\n  renderScene: (props: {\r\n    route: T,\r\n    jumpTo: (key: string) => mixed,\r\n  }) => ?React.Node,\r\n  /**\r\n   * Callback which returns a React Element to be used as tab icon.\r\n   */\r\n  renderIcon?: (props: {\r\n    route: T,\r\n    focused: boolean,\r\n    color: string,\r\n  }) => React.Node,\r\n  /**\r\n   * Callback which React Element to be used as tab label.\r\n   */\r\n  renderLabel?: (props: {\r\n    route: T,\r\n    focused: boolean,\r\n    color: string,\r\n  }) => React.Node,\r\n  /**\r\n   * Get label text for the tab, uses `route.title` by default. Use `renderLabel` to replace label component.\r\n   */\r\n  getLabelText?: (props: { route: T }) => string,\r\n  /**\r\n   * Get accessibility label for the tab button. This is read by the screen reader when the user taps the tab.\r\n   * Uses `route.accessibilityLabel` by default.\r\n   */\r\n  getAccessibilityLabel?: (props: { route: T }) => ?string,\r\n  /**\r\n   * Get the id to locate this tab button in tests, uses `route.testID` by default.\r\n   */\r\n  getTestID?: (props: { route: T }) => ?string,\r\n  /**\r\n   * Get color for the tab, uses `route.color` by default.\r\n   */\r\n  getColor?: (props: { route: T }) => string,\r\n  /**\r\n   * Function to execute on tab press. It receives the route for the pressed tab, useful for things like scroll to top.\r\n   */\r\n  onTabPress?: (props: { route: T }) => mixed,\r\n  /**\r\n   * Custom color for icon and label in the active tab.\r\n   */\r\n  activeColor?: string,\r\n  /**\r\n   * Custom color for icon and label in the inactive tab.\r\n   */\r\n  inactiveColor?: string,\r\n  /**\r\n   * Style for the bottom navigation bar.\r\n   * You can set a bottom padding here if you have a translucent navigation bar on Android:\r\n   *\r\n   * ```js\r\n   * barStyle={{ paddingBottom: 48 }}\r\n   * ```\r\n   */\r\n  barStyle?: any,\r\n  style?: any,\r\n  /**\r\n   * @optional\r\n   */\r\n  theme: Theme,\r\n};\r\n\r\ntype State = {\r\n  /**\r\n   * Active state of individual tab items, active state is 1 and inactve state is 0.\r\n   */\r\n  tabs: Animated.Value[],\r\n  /**\r\n   * The top offset for each tab item to position it offscreen.\r\n   * Placing items offscreen helps to save memory usage for inactive screens with removeClippedSubviews.\r\n   * We use animated values for this to prevent unnecesary re-renders.\r\n   */\r\n  offsets: Animated.Value[],\r\n  /**\r\n   * Index of the currently active tab. Used for setting the background color.\r\n   * Use don't use the color as an animated value directly, because `setValue` seems to be buggy with colors.\r\n   */\r\n  index: Animated.Value,\r\n  /**\r\n   * Animation for the background color ripple, used to determine it's scale and opacity.\r\n   */\r\n  ripple: Animated.Value,\r\n  /**\r\n   * Layout of the tab bar. The width is used to determine the size and position of the ripple.\r\n   */\r\n  layout: { height: number, width: number, measured: boolean },\r\n  /**\r\n   * Currently active index. Used only for getDerivedStateFromProps.\r\n   */\r\n  current: number,\r\n  /**\r\n   * Previously active index. Used to determine the position of the ripple.\r\n   */\r\n  previous: number,\r\n  /**\r\n   * List of loaded tabs, tabs will be loaded when navigated to.\r\n   */\r\n  loaded: number[],\r\n};\r\n\r\nconst MIN_RIPPLE_SCALE = 0.001; // Minimum scale is not 0 due to bug with animation\r\nconst MIN_TAB_WIDTH = 96;\r\nconst MAX_TAB_WIDTH = 168;\r\nconst BAR_HEIGHT = 56;\r\nconst FAR_FAR_AWAY = 9999;\r\n\r\nconst Touchable =\r\n  Platform.OS === 'android'\r\n    ? TouchableRipple\r\n    : ({ style, children, ...rest }) => (\r\n        <TouchableWithoutFeedback {...rest}>\r\n          <View style={style}>{children}</View>\r\n        </TouchableWithoutFeedback>\r\n      );\r\n\r\nclass SceneComponent extends React.PureComponent<*> {\r\n  render() {\r\n    const { component, ...rest } = this.props;\r\n    return React.createElement(component, rest);\r\n  }\r\n}\r\n\r\n/**\r\n * Bottom navigation provides quick navigation between top-level views of an app with a bottom tab bar.\r\n * It is primarily designed for use on mobile.\r\n *\r\n * For integration with React Navigation, you can use [react-navigation-material-bottom-tab-navigator](https://github.com/react-navigation/react-navigation-material-bottom-tab-navigator).\r\n *\r\n * <div class=\"screenshots\">\r\n *   <img class=\"medium\" src=\"screenshots/bottom-navigation.gif\" />\r\n * </div>\r\n *\r\n * ## Usage\r\n * ```js\r\n * import * as React from 'react';\r\n * import { BottomNavigation, Text } from 'react-native-paper';\r\n *\r\n * const MusicRoute = () => <Text>Music</Text>;\r\n *\r\n * const AlbumsRoute = () => <Text>Albums</Text>;\r\n *\r\n * const RecentsRoute = () => <Text>Recents</Text>;\r\n *\r\n * export default class MyComponent extends React.Component {\r\n *   state = {\r\n *     index: 0,\r\n *     routes: [\r\n *       { key: 'music', title: 'Music', icon: 'queue-music' },\r\n *       { key: 'albums', title: 'Albums', icon: 'album' },\r\n *       { key: 'recents', title: 'Recents', icon: 'history' },\r\n *     ],\r\n *   };\r\n *\r\n *   _handleIndexChange = index => this.setState({ index });\r\n *\r\n *   _renderScene = BottomNavigation.SceneMap({\r\n *     music: MusicRoute,\r\n *     albums: AlbumsRoute,\r\n *     recents: RecentsRoute,\r\n *   });\r\n *\r\n *   render() {\r\n *     return (\r\n *       <BottomNavigation\r\n *         navigationState={this.state}\r\n *         onIndexChange={this._handleIndexChange}\r\n *         renderScene={this._renderScene}\r\n *       />\r\n *     );\r\n *   }\r\n * }\r\n * ```\r\n */\r\nclass BottomNavigation<T: *> extends React.Component<Props<T>, State> {\r\n  /**\r\n   * Function which takes a map of route keys to components.\r\n   * Pure components are used to minmize re-rendering of the pages.\r\n   * This drastically improves the animation performance.\r\n   */\r\n  static SceneMap(scenes: {\r\n    [key: string]: React.ComponentType<{\r\n      route: T,\r\n      jumpTo: (key: string) => mixed,\r\n    }>,\r\n  }) {\r\n    return ({ route, jumpTo }: *) => (\r\n      <SceneComponent\r\n        key={route.key}\r\n        component={scenes[route.key]}\r\n        route={route}\r\n        jumpTo={jumpTo}\r\n      />\r\n    );\r\n  }\r\n\r\n  static defaultProps = {\r\n    labeled: true,\r\n  };\r\n\r\n  static getDerivedStateFromProps(nextProps, prevState) {\r\n    const { index, routes } = nextProps.navigationState;\r\n\r\n    // Re-create animated values if routes have been added/removed\r\n    // Preserve previous animated values if they exist, so we don't break animations\r\n    const tabs = routes.map(\r\n      // focused === 1, unfocused === 0\r\n      (_, i) => prevState.tabs[i] || new Animated.Value(i === index ? 1 : 0)\r\n    );\r\n    const offsets = routes.map(\r\n      // offscreen === 1, normal === 0\r\n      (_, i) => prevState.offsets[i] || new Animated.Value(i === index ? 0 : 1)\r\n    );\r\n\r\n    const nextState = {\r\n      tabs,\r\n      offsets,\r\n    };\r\n\r\n    if (index !== prevState.current) {\r\n      /* $FlowFixMe */\r\n      Object.assign(nextState, {\r\n        // Store the current index in state so that we can later check if the index has changed\r\n        current: index,\r\n        previous: prevState.current,\r\n        // Set the current tab to be loaded if it was not loaded before\r\n        loaded: prevState.loaded.includes(index)\r\n          ? prevState.loaded\r\n          : [...prevState.loaded, index],\r\n      });\r\n    }\r\n\r\n    return nextState;\r\n  }\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    const { index } = this.props.navigationState;\r\n\r\n    this.state = {\r\n      tabs: [],\r\n      offsets: [],\r\n      index: new Animated.Value(index),\r\n      ripple: new Animated.Value(MIN_RIPPLE_SCALE),\r\n      touch: new Animated.Value(MIN_RIPPLE_SCALE),\r\n      layout: { height: 0, width: 0, measured: false },\r\n      current: index,\r\n      previous: 0,\r\n      loaded: [index],\r\n    };\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.navigationState.index === this.props.navigationState.index) {\r\n      return;\r\n    }\r\n\r\n    const shifting = this._isShifting();\r\n    const { routes, index } = this.props.navigationState;\r\n\r\n    // Reset offsets of previous and current tabs before animation\r\n    this.state.offsets.forEach((offset, i) => {\r\n      if (i === index || i === prevProps.navigationState.index) {\r\n        offset.setValue(0);\r\n      }\r\n    });\r\n\r\n    // Reset the ripple to avoid glitch if it's currently animating\r\n    this.state.ripple.setValue(MIN_RIPPLE_SCALE);\r\n\r\n    Animated.parallel([\r\n      Animated.timing(this.state.ripple, {\r\n        toValue: 1,\r\n        duration: shifting ? 400 : 0,\r\n        useNativeDriver: true,\r\n      }),\r\n      ...routes.map((_, i) =>\r\n        Animated.timing(this.state.tabs[i], {\r\n          toValue: i === index ? 1 : 0,\r\n          duration: shifting ? 150 : 75,\r\n          useNativeDriver: true,\r\n        })\r\n      ),\r\n    ]).start(({ finished }) => {\r\n      // Workaround a bug in native animations where this is reset after first animation\r\n      this.state.tabs.map((tab, i) => tab.setValue(i === index ? 1 : 0));\r\n\r\n      // Update the index to change bar's bacground color and then hide the ripple\r\n      this.state.index.setValue(index);\r\n      this.state.ripple.setValue(MIN_RIPPLE_SCALE);\r\n\r\n      if (finished) {\r\n        // Position all inactive screens offscreen to save memory usage\r\n        // Only do it when animation has finished to avoid glitches mid-transition if switching fast\r\n        this.state.offsets.forEach((offset, i) => {\r\n          if (i === index) {\r\n            offset.setValue(0);\r\n          } else {\r\n            offset.setValue(1);\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  _handleLayout = e =>\r\n    this.setState({\r\n      layout: {\r\n        height: e.nativeEvent.layout.height,\r\n        width: e.nativeEvent.layout.width,\r\n        measured: true,\r\n      },\r\n    });\r\n\r\n  _handleTabPress = (index: number) => {\r\n    const { navigationState, onTabPress, onIndexChange } = this.props;\r\n\r\n    if (onTabPress) {\r\n      onTabPress({\r\n        route: navigationState.routes[index],\r\n      });\r\n    }\r\n\r\n    if (index !== navigationState.index) {\r\n      onIndexChange(index);\r\n    }\r\n  };\r\n\r\n  _jumpTo = (key: string) => {\r\n    const index = this.props.navigationState.routes.findIndex(\r\n      route => route.key === key\r\n    );\r\n\r\n    this.props.onIndexChange(index);\r\n  };\r\n\r\n  _isShifting = () =>\r\n    typeof this.props.shifting === 'boolean'\r\n      ? this.props.shifting\r\n      : this.props.navigationState.routes.length > 3;\r\n\r\n  render() {\r\n    const {\r\n      navigationState,\r\n      renderScene,\r\n      renderIcon,\r\n      renderLabel,\r\n      getLabelText = ({ route }: Object) => route.title,\r\n      getColor = ({ route }: Object) => route.color,\r\n      getAccessibilityLabel = ({ route }: Object) => route.accessibilityLabel,\r\n      getTestID = ({ route }: Object) => route.testID,\r\n      activeColor,\r\n      inactiveColor,\r\n      barStyle,\r\n      labeled,\r\n      style,\r\n      theme,\r\n    } = this.props;\r\n    const { layout, loaded } = this.state;\r\n    const { routes } = navigationState;\r\n    const { colors } = theme;\r\n\r\n    const shifting = this._isShifting();\r\n\r\n    const { backgroundColor: approxBackgroundColor = colors.primary } =\r\n      StyleSheet.flatten(barStyle) || {};\r\n\r\n    const backgroundColor = shifting\r\n      ? this.state.index.interpolate({\r\n          inputRange: routes.map((_, i) => i),\r\n          outputRange: routes.map(\r\n            route => getColor({ route }) || approxBackgroundColor\r\n          ),\r\n        })\r\n      : approxBackgroundColor;\r\n\r\n    const isDark = !color(approxBackgroundColor).light();\r\n\r\n    const textColor = isDark ? white : black;\r\n    const activeTintColor =\r\n      typeof activeColor !== 'undefined' ? activeColor : textColor;\r\n    const inactiveTintColor =\r\n      typeof inactiveColor !== 'undefined'\r\n        ? inactiveColor\r\n        : color(textColor)\r\n            .alpha(0.5)\r\n            .rgb()\r\n            .string();\r\n\r\n    const touchColor = color(textColor)\r\n      .alpha(0.12)\r\n      .rgb()\r\n      .string();\r\n\r\n    const maxTabWidth = routes.length > 3 ? MIN_TAB_WIDTH : MAX_TAB_WIDTH;\r\n    const tabWidth = Math.min(\r\n      // Account for horizontal padding around the items\r\n      (layout.width * 4) / routes.length,\r\n      maxTabWidth\r\n    );\r\n\r\n    return (\r\n      <View\r\n        style={[styles.container, style]}\r\n        onLayout={this._handleLayout}\r\n        pointerEvents={layout.measured ? 'auto' : 'none'}\r\n      >\r\n        <View style={[styles.content, { backgroundColor: colors.background }]}>\r\n          {routes.map((route, index) => {\r\n            if (!loaded.includes(index)) {\r\n              // Don't render a screen if we've never navigated to it\r\n              return null;\r\n            }\r\n\r\n            const opacity = this.state.tabs[index];\r\n            const top = this.state.offsets[index].interpolate({\r\n              inputRange: [0, 1],\r\n              outputRange: [0, FAR_FAR_AWAY],\r\n            });\r\n\r\n            const focused = navigationState.index === index;\r\n\r\n            return (\r\n              <Animated.View\r\n                key={route.key}\r\n                pointerEvents={focused ? 'auto' : 'none'}\r\n                accessibilityElementsHidden={!focused}\r\n                importantForAccessibility={\r\n                  focused ? 'auto' : 'no-hide-descendants'\r\n                }\r\n                style={[StyleSheet.absoluteFill, { opacity }]}\r\n                collapsable={false}\r\n                removeClippedSubviews={\r\n                  // On iOS, set removeClippedSubviews to true only when not focused\r\n                  // This is an workaround for a bug where the clipped view never re-appears\r\n                  Platform.OS === 'ios' ? navigationState.index !== index : true\r\n                }\r\n              >\r\n                <Animated.View style={[styles.content, { top }]}>\r\n                  {renderScene({\r\n                    route,\r\n                    jumpTo: this._jumpTo,\r\n                  })}\r\n                </Animated.View>\r\n              </Animated.View>\r\n            );\r\n          })}\r\n        </View>\r\n        <Surface style={[styles.bar, barStyle, { backgroundColor }]}>\r\n          <SafeAreaView\r\n            style={[styles.items, { maxWidth: maxTabWidth * routes.length }]}\r\n          >\r\n            {shifting ? (\r\n              <Animated.View\r\n                pointerEvents=\"none\"\r\n                style={[\r\n                  styles.ripple,\r\n                  {\r\n                    // Since we have a single ripple, we have to reposition it so that it appears to expand from active tab.\r\n                    // We need to move it from the top to center of the tab bar and from the left to the active tab.\r\n                    top: BAR_HEIGHT / 2 - layout.width / 8,\r\n                    left:\r\n                      navigationState.index * tabWidth +\r\n                      tabWidth / 2 -\r\n                      layout.width / 8,\r\n                    height: layout.width / 4,\r\n                    width: layout.width / 4,\r\n                    borderRadius: layout.width / 2,\r\n                    backgroundColor: getColor({\r\n                      route: routes[navigationState.index],\r\n                    }),\r\n                    transform: [\r\n                      {\r\n                        // Scale to twice the size  to ensure it covers the whole tab bar\r\n                        scale: this.state.ripple.interpolate({\r\n                          inputRange: [0, 1],\r\n                          outputRange: [0, 8],\r\n                        }),\r\n                      },\r\n                    ],\r\n                    opacity: this.state.ripple.interpolate({\r\n                      inputRange: [0, MIN_RIPPLE_SCALE, 0.3, 1],\r\n                      outputRange: [0, 0, 1, 1],\r\n                    }),\r\n                  },\r\n                ]}\r\n              />\r\n            ) : null}\r\n            {routes.map((route, index) => {\r\n              const focused = navigationState.index === index;\r\n              const active = this.state.tabs[index];\r\n\r\n              // Scale up in the label\r\n              const scale =\r\n                labeled && shifting\r\n                  ? active.interpolate({\r\n                      inputRange: [0, 1],\r\n                      outputRange: [0.5, 1],\r\n                    })\r\n                  : 1;\r\n\r\n              // Move down the icon to account for no-label in shifting and smaller label in non-shifting.\r\n              const translateY = labeled\r\n                ? shifting\r\n                  ? active.interpolate({\r\n                      inputRange: [0, 1],\r\n                      outputRange: [7, 0],\r\n                    })\r\n                  : 0\r\n                : 7;\r\n\r\n              // We render the active icon and label on top of inactive ones and cross-fade them on change.\r\n              // This trick gives the illusion that we are animating between active and inactive colors.\r\n              // This is to ensure that we can use native driver, as colors cannot be animated with native driver.\r\n              const activeOpacity = active;\r\n              const inactiveOpacity = active.interpolate({\r\n                inputRange: [0, 1],\r\n                outputRange: [1, 0],\r\n              });\r\n\r\n              return (\r\n                <Touchable\r\n                  key={route.key}\r\n                  borderless\r\n                  rippleColor={touchColor}\r\n                  onPress={() => this._handleTabPress(index)}\r\n                  testID={getTestID({ route })}\r\n                  accessibilityLabel={getAccessibilityLabel({ route })}\r\n                  accessibilityTraits={\r\n                    focused ? ['button', 'selected'] : 'button'\r\n                  }\r\n                  accessibilityComponentType=\"button\"\r\n                  accessibilityRole=\"button\"\r\n                  accessibilityStates={['selected']}\r\n                  style={styles.item}\r\n                >\r\n                  <View pointerEvents=\"none\">\r\n                    <Animated.View\r\n                      style={[\r\n                        styles.iconContainer,\r\n                        { transform: [{ translateY }] },\r\n                      ]}\r\n                    >\r\n                      <Animated.View\r\n                        style={[styles.iconWrapper, { opacity: activeOpacity }]}\r\n                      >\r\n                        {renderIcon ? (\r\n                          renderIcon({\r\n                            route,\r\n                            focused: true,\r\n                            color: activeTintColor,\r\n                          })\r\n                        ) : (\r\n                          <Icon\r\n                            source={(route: Object).icon}\r\n                            color={activeTintColor}\r\n                            size={24}\r\n                          />\r\n                        )}\r\n                      </Animated.View>\r\n                      <Animated.View\r\n                        style={[\r\n                          styles.iconWrapper,\r\n                          { opacity: inactiveOpacity },\r\n                        ]}\r\n                      >\r\n                        {renderIcon ? (\r\n                          renderIcon({\r\n                            route,\r\n                            focused: false,\r\n                            color: inactiveTintColor,\r\n                          })\r\n                        ) : (\r\n                          <Icon\r\n                            source={(route: Object).icon}\r\n                            color={inactiveTintColor}\r\n                            size={24}\r\n                          />\r\n                        )}\r\n                      </Animated.View>\r\n                    </Animated.View>\r\n                    {labeled ? (\r\n                      <Animated.View\r\n                        style={[\r\n                          styles.labelContainer,\r\n                          {\r\n                            transform: [{ scale }],\r\n                          },\r\n                        ]}\r\n                      >\r\n                        <Animated.View\r\n                          style={[\r\n                            styles.labelWrapper,\r\n                            { opacity: activeOpacity },\r\n                          ]}\r\n                        >\r\n                          {renderLabel ? (\r\n                            renderLabel({\r\n                              route,\r\n                              focused: true,\r\n                              color: activeTintColor,\r\n                            })\r\n                          ) : (\r\n                            <AnimatedText\r\n                              style={[\r\n                                styles.label,\r\n                                {\r\n                                  color: activeTintColor,\r\n                                },\r\n                              ]}\r\n                            >\r\n                              {getLabelText({ route })}\r\n                            </AnimatedText>\r\n                          )}\r\n                        </Animated.View>\r\n                        {shifting ? null : (\r\n                          <Animated.View\r\n                            style={[\r\n                              styles.labelWrapper,\r\n                              { opacity: inactiveOpacity },\r\n                            ]}\r\n                          >\r\n                            {renderLabel ? (\r\n                              renderLabel({\r\n                                route,\r\n                                focused: false,\r\n                                color: inactiveTintColor,\r\n                              })\r\n                            ) : (\r\n                              <AnimatedText\r\n                                style={[\r\n                                  styles.label,\r\n                                  {\r\n                                    color: inactiveTintColor,\r\n                                  },\r\n                                ]}\r\n                              >\r\n                                {getLabelText({ route })}\r\n                              </AnimatedText>\r\n                            )}\r\n                          </Animated.View>\r\n                        )}\r\n                      </Animated.View>\r\n                    ) : (\r\n                      <View style={styles.labelContainer} />\r\n                    )}\r\n                  </View>\r\n                </Touchable>\r\n              );\r\n            })}\r\n          </SafeAreaView>\r\n        </Surface>\r\n      </View>\r\n    );\r\n  }\r\n}\r\n\r\npolyfill(BottomNavigation);\r\n\r\nexport default withTheme(BottomNavigation);\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n  },\r\n  content: {\r\n    flex: 1,\r\n  },\r\n  bar: {\r\n    elevation: 8,\r\n    overflow: 'hidden',\r\n    alignItems: 'center',\r\n  },\r\n  items: {\r\n    flexDirection: 'row',\r\n  },\r\n  item: {\r\n    flex: 1,\r\n    // Top padding is 6 and bottom padding is 10\r\n    // The extra 4dp bottom padding is offset by label's height\r\n    paddingVertical: 6,\r\n  },\r\n  ripple: {\r\n    position: 'absolute',\r\n  },\r\n  iconContainer: {\r\n    height: 24,\r\n    width: 24,\r\n    marginTop: 2,\r\n    marginHorizontal: 12,\r\n    alignSelf: 'center',\r\n  },\r\n  iconWrapper: {\r\n    ...StyleSheet.absoluteFillObject,\r\n    alignItems: 'center',\r\n  },\r\n  labelContainer: {\r\n    height: 16,\r\n    paddingBottom: 2,\r\n  },\r\n  labelWrapper: {\r\n    ...StyleSheet.absoluteFillObject,\r\n  },\r\n  label: {\r\n    fontSize: 12,\r\n    textAlign: 'center',\r\n    backgroundColor: 'transparent',\r\n  },\r\n});\r\n"]},"metadata":{},"sourceType":"module"}